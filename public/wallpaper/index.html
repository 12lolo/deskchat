<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>deskchat live — Wallpaper</title>
    <style>
        :root {
            --bg1: #0f172a; /* slate-900 */
            --bg2: #1e293b; /* slate-800 */
            --card: rgba(255,255,255,0.08);
            --text: #e5e7eb; /* gray-200 */
            --muted: #94a3b8; /* slate-400 */
            --accent: #60a5fa; /* blue-400 */
            --shadow: rgba(0,0,0,0.35);
            --font: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Arial, sans-serif;
            --font-size: clamp(14px, 1.6vw, 22px);
            --max-messages: 100;
            --accent2: #a78bfa; /* violet-400 */
            --accent3: #34d399; /* emerald-400 */
            --card-border: rgba(255,255,255,0.12);
            --embed-min-h: 140px;
            --embed-max-h: 50vh;
            --fade-h: 56px;
            --gradient: radial-gradient(120% 120% at 100% 0%, var(--bg2), var(--bg1));
        }

        /* Light theme overrides */
        :root[data-theme='light'] {
            --bg1: #e2e8f0; /* slate-200 */
            --bg2: #f1f5f9; /* slate-100 */
            --card: rgba(0,0,0,0.06);
            --text: #1e293b;
            --muted: #475569;
            --accent: #2563eb; /* blue-600 */
            --accent2: #7c3aed; /* violet-600 */
            --accent3: #059669; /* emerald-600 */
            --card-border: rgba(0,0,0,0.15);
            --shadow: rgba(0,0,0,0.25);
        }

        html, body {
            margin: 0; padding: 0; height: 100%; width: 100%;
            background: var(--gradient);
            color: var(--text);
            font-family: var(--font);
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            overflow: hidden;
            user-select: none;
            pointer-events: none; /* Let desktop clicks pass through */
        }

        .wrap {
            position: absolute; inset: 0; box-sizing: border-box;
            display: flex; flex-direction: column; align-items: var(--h-align, center); justify-content: center;
            min-height: 100vh;
            width: 100vw;
            padding: 4vh 5vw 12vh 5vw;
            pointer-events: none;
        }

        .headline {
            font-weight: 600; letter-spacing: 0.02em; font-size: clamp(16px, 2vw, 26px);
            color: var(--muted);
            text-shadow: 0 1px 2px var(--shadow);
            margin-bottom: 1.5vh;
        }

        .settings-btn {
            position: absolute; top: 2.5vh; right: 5vw; z-index: 10;
            background: none; border: none; cursor: pointer; padding: 6px;
            border-radius: 50%; transition: background 0.15s;
            width: 36px; height: 36px; display: flex; align-items: center; justify-content: center;
            pointer-events: auto;
        }
        .settings-btn:hover, .settings-btn:focus { background: rgba(255,255,255,0.10); }
        .settings-btn svg { width: 24px; height: 24px; fill: var(--muted); }

        .settings-menu {
            position: absolute; top: 54px; right: 5vw; min-width: 210px;
            background: var(--card); color: var(--text); border-radius: 12px;
            box-shadow: 0 8px 32px -8px var(--shadow);
            padding: 18px 20px 14px 20px; z-index: 20;
            display: none; flex-direction: column; gap: 16px;
            font-size: 1em;
            pointer-events: auto;
            animation: menuIn 220ms cubic-bezier(.2,.8,.2,1);
        }
        .settings-menu.open { display: flex; }
        @keyframes menuIn {
            0% { opacity: 0; transform: translateY(-12px) scale(0.98); }
            100% { opacity: 1; transform: translateY(0) scale(1); }
        }
        .settings-menu label { font-size: 0.98em; color: var(--muted); margin-bottom: 2px; }
        .settings-menu select, .settings-menu input[type=range] {
            width: 100%; margin-top: 2px; margin-bottom: 6px;
        }
        .settings-menu .row { display: flex; align-items: center; gap: 10px; }
        .settings-menu .row input[type=range] { flex: 1; }
        .settings-menu .row .val { min-width: 2.5em; text-align: right; color: var(--accent); font-size: 0.98em; }

        #feed {
            display: flex; flex-direction: column; gap: calc(8px * var(--msg-scale, 1));
            align-self: var(--h-align, center);
            align-items: var(--msg-align, center);
            overflow-y: auto; overflow-x: hidden; /* programmatic scroll only */
            scroll-behavior: smooth; max-height: 82vh; min-height: 50vh; min-width: 340px; width: min(94vw, calc(85ch * var(--msg-scale, 1)));
            scrollbar-width: none; -ms-overflow-style: none;
            position: relative; box-sizing: border-box;
            padding: 0 8px calc(var(--fade-h) + 6px) 8px;
        }
        #feed::-webkit-scrollbar { display: none; }
 

        .msg {
            max-width: 100%; width: 100%; box-sizing: border-box; padding: calc(8px * var(--msg-scale, 1)) calc(12px * var(--msg-scale, 1)); border-radius: 12px;
            position: relative;
            background: linear-gradient(180deg, rgba(255,255,255,0.08), rgba(255,255,255,0.06));
            backdrop-filter: blur(8px) saturate(120%);
            border: 1px solid var(--card-border);
            box-shadow: 0 6px 18px -6px var(--shadow);
            opacity: 0; transform: translateY(16px);
            transition: opacity 260ms ease, transform 320ms cubic-bezier(.2,.8,.2,1), box-shadow 300ms ease;
            font-size: calc(var(--font-size) * var(--msg-scale, 1));
        }
        /* temporarily disable smooth scrolling during jump-to-bottom operations */
        #feed.no-smooth { scroll-behavior: auto !important; }
        .msg.show { opacity: 1; transform: translateY(0); }
        .msg::before {
            content: ""; position: absolute; left: 0; top: 0; bottom: 0; width: 4px; border-radius: 14px 0 0 14px;
            background: linear-gradient(180deg, var(--accent), var(--accent2), var(--accent3));
            filter: saturate(120%);
            opacity: 0.85;
        }
        .msg.new { animation: popIn 420ms cubic-bezier(.2,.9,.2,1), glow 1200ms ease-out; }
        @keyframes popIn {
            0% { opacity: 0; transform: translateY(22px) scale(0.99); }
            60% { opacity: 1; transform: translateY(0) scale(1.01); }
            100% { transform: translateY(0) scale(1); }
        }
        @keyframes glow {
            0% { box-shadow: 0 14px 40px -18px rgba(96,165,250,0.65), 0 0 0 0 rgba(96,165,250,0.0); }
            100% { box-shadow: 0 10px 24px -8px var(--shadow); }
        }
        .meta { font-size: 0.85em; color: var(--muted); margin-bottom: 4px; }
        .handle { color: var(--accent); font-weight: 600; }
        .content { font-size: var(--font-size); line-height: 1.35; white-space: pre-wrap; word-wrap: break-word; }
        .status {
            align-self: end; justify-self: end; color: var(--muted); font-size: 12px;
            text-shadow: 0 1px 2px var(--shadow);
        }
        .watermark { position: absolute; bottom: 2vh; left: 5vw; opacity: 0.3; color: var(--muted); font-size: 12px; }

        /* Embeds (smaller) */
    :root { --embed-min-h: 90px; --embed-max-h: 32vh; }
    .embed { margin-top: 6px; border-radius: 10px; overflow: hidden; box-shadow: 0 4px 14px -6px var(--shadow); width: 100%; }
    .embed.tenor { width: 100%; max-width: 100%; min-height: var(--embed-min-h); max-height: var(--embed-max-h); }
    .embed-media { display: block; width: 100%; height: auto; object-fit: contain; background: rgba(255,255,255,0.04); max-height: var(--embed-max-h); }
    .embed img.embed-media { min-height: var(--embed-min-h); }
    video.embed-media { max-height: var(--embed-max-h); }
        @media (prefers-reduced-motion: reduce) {
            #feed { scroll-behavior: auto; }
            .msg { transition: none; }
            .msg.new { animation: none; }
        }
    </style>
    <button class="settings-btn" id="settingsBtn" title="Settings" tabindex="0" aria-label="Settings">
        <svg viewBox="0 0 24 24"><path d="M12 15.5A3.5 3.5 0 1 0 12 8.5a3.5 3.5 0 0 0 0 7zm7.43-2.9l1.77-1.02a1 1 0 0 0 .37-1.36l-1.7-2.94a1 1 0 0 0-1.28-.45l-1.77 1.02a7.03 7.03 0 0 0-1.52-.88l-.27-1.97A1 1 0 0 0 14.04 4h-3.08a1 1 0 0 0-.99.85l-.27 1.97a7.03 7.03 0 0 0-1.52.88l-1.77-1.02a1 1 0 0 0-1.28.45l-1.7 2.94a1 1 0 0 0 .37 1.36l1.77 1.02c-.06.32-.1.65-.13.99s-.04.67-.04 1.01.01.68.04 1.01c.03.34.07.67.13.99l-1.77 1.02a1 1 0 0 0-.37 1.36l1.7 2.94a1 1 0 0 0 1.28.45l1.77-1.02c.47.34.98.64 1.52.88l.27 1.97a1 1 0 0 0 .99.85h3.08a1 1 0 0 0 .99-.85l.27-1.97c.54-.24 1.05-.54 1.52-.88l1.77 1.02a1 1 0 0 0 1.28-.45l1.7-2.94a1 1 0 0 0-.37-1.36l-1.77-1.02c.06-.32.1-.65.13-.99.03-.33.04-.67.04-1.01s-.01-.68-.04-1.01a7.6 7.6 0 0 0-.13-.99z"/></svg>
    </button>
    <div class="settings-menu" id="settingsMenu" tabindex="-1">
        <div>
            <label for="msgScale">Message size</label>
            <div class="row">
                <input type="range" id="msgScale" min="0.7" max="1.5" step="0.01" value="0.9">
                <span class="val" id="msgScaleVal">0.90x</span>
            </div>
        </div>
        <div>
            <label for="pollInterval">Refresh rate</label>
            <div class="row">
                <input type="range" id="pollInterval" min="500" max="10000" step="100" value="2500">
                <span class="val" id="pollIntervalVal">2500 ms</span>
            </div>
        </div>
        <div>
            <label for="positionSelect">Position</label>
            <select id="positionSelect">
                <option value="left">Left</option>
                <option value="center" selected>Center</option>
                <option value="right">Right</option>
            </select>
        </div>
        <div>
            <label for="themeSelect">Theme</label>
            <select id="themeSelect">
                <option value="dark">Dark</option>
                <option value="light">Light</option>
            </select>
        </div>
    </div>
    <div class="wrap">
        <div class="headline">deskchat live</div>
        <div id="feed" aria-live="polite" aria-busy="false"></div>
        <div class="status" id="status">Connecting…</div>
    <div class="watermark">Keys: D debug · +/- size · [ ] position · T theme</div>
    </div>
    <script>
        (function () {
            'use strict';

            // Config via URL params (e.g., ?api=https://api.deskchat.live&interval=2500&limit=30&max=100)
            const params = new URLSearchParams(location.search);
            const API_BASE = (params.get('api') || 'https://api.deskchat.live').replace(/\/$/, '');
            let POLL_MS = Math.max(800, Number(params.get('interval') || 2500));
            const PAGE_LIMIT = Math.min(100, Math.max(1, Number(params.get('limit') || 30)));
            const MAX_DOM = Math.min(300, Math.max(10, Number(params.get('max') || 100)));
            const SCROLL_MS = Math.max(300, Math.min(1500, Number(params.get('scroll_ms') || 700)));

            // DOM elements
            const feed = document.getElementById('feed');
            const status = document.getElementById('status');

            // State
            let lastId = 0;
            let timer = null;
            let backoff = POLL_MS;
            let debug = false;
            let hadTenor = false;
            // Force bottom lock window to handle late layout (embeds/fonts)
            let forceBottomUntil = 0;
            const shouldForceBottom = () => Date.now() < forceBottomUntil;
            const lockBottom = (ms = 1500) => { forceBottomUntil = Date.now() + ms; };
            // Embed helpers
            const TENOR_RE = /https?:\/\/(?:www\.)?tenor\.com\/view\/[a-z0-9-]*-(\d+)/ig;
            const DIRECT_MEDIA_RE = /https?:\/\/[^\s]+?\.(?:gif|mp4|webm)(?:\?[^\s]*)?(?=\b|$)/ig;

            let tenorScriptLoaded = false;
            let tenorScriptLoading = false;
            function ensureTenorScript() {
                if (tenorScriptLoaded || tenorScriptLoading) return;
                tenorScriptLoading = true;
                const s = document.createElement('script');
                s.src = 'https://tenor.com/embed.js';
                s.async = true;
                s.onload = () => { tenorScriptLoaded = true; tenorScriptLoading = false; try { window.Tenor && window.Tenor.Embed && window.Tenor.Embed.render(); } catch {} };
                document.head.appendChild(s);
            }

            function buildEmbedsFromText(text) {
                const nodes = [];
                try {
                    const t = String(text ?? '');
                    TENOR_RE.lastIndex = 0; DIRECT_MEDIA_RE.lastIndex = 0;
                    // 1. Tenor view links (limit 2)
                    const tenorIds = [];
                    let m;
                    while ((m = TENOR_RE.exec(t)) && tenorIds.length < 2) {
                        const raw = m[0];
                        const idMatch = raw.match(/-(\d+)/);
                        if (idMatch) tenorIds.push(idMatch[1]);
                    }
                    if (tenorIds.length) hadTenor = true;
                    for (const id of tenorIds) {
                        const outer = document.createElement('div');
                        outer.className = 'embed tenor';
                        const div = document.createElement('div');
                        div.className = 'tenor-gif-embed';
                        div.setAttribute('data-postid', id);
                        div.setAttribute('data-share-method', 'host');
                        div.setAttribute('data-aspect-ratio', '1.4');
                        div.setAttribute('data-width', '100%');
                        outer.appendChild(div);
                        nodes.push(outer);
                    }
                    // 2. Direct media (gif/mp4/webm) gather (limit 2, overall embeds <=3)
                    if (nodes.length < 3) {
                        let dm; let collected = 0;
                        while ((dm = DIRECT_MEDIA_RE.exec(t)) && nodes.length < 3) {
                            const url = dm[0];
                            const ext = (url.split('?')[0].split('.').pop() || '').toLowerCase();
                            const wrap = document.createElement('div');
                            wrap.className = 'embed';
                            if (ext === 'gif') {
                                const img = document.createElement('img');
                                img.src = url; img.alt = 'GIF'; img.loading = 'lazy'; img.decoding='async'; img.className = 'embed-media';
                                img.onerror = () => { img.alt = 'GIF failed'; img.style.opacity = '0.4'; };
                                wrap.appendChild(img);
                            } else {
                                const video = document.createElement('video');
                                video.src = url; video.autoplay = true; video.loop = true; video.muted = true; video.playsInline = true; video.controls = false; video.className='embed-media';
                                video.onerror = () => { video.replaceWith(document.createTextNode('[video failed]')); };
                                wrap.appendChild(video);
                            }
                            nodes.push(wrap);
                            collected++; if (collected >= 2) break;
                        }
                    }
                } catch (e) { /* noop */ }
                return nodes;
            }

            // Remove Tenor/media URLs from the visible text when we render embeds
            function stripEmbedsFromText(text) {
                try {
                    let out = String(text ?? '');
                    const TENOR_URL_RE = /https?:\/\/(?:www\.)?tenor\.com\/view\/[^\s]+/ig;
                    const DIRECT_MEDIA_URL_RE = /https?:\/\/[^\s]+?\.(?:gif|mp4|webm)(?:\?[^\s]*)?\b/ig;
                    out = out.replace(TENOR_URL_RE, ' ').replace(DIRECT_MEDIA_URL_RE, ' ');
                    out = out.replace(/\s{2,}/g, ' ').trim();
                    return out;
                } catch { return String(text ?? ''); }
            }

            function log(...a) { if (debug) console.log('[deskchat]', ...a); }

            function setStatus(text) {
                status.textContent = text;
            }

            function visible() { return !document.hidden; }

            function escapeText(s) {
                // Ensure string and strip control chars
                return String(s ?? '').replace(/[\u0000-\u001F\u007F]/g, '');
            }

            function isoToLocal(iso) {
                try { return new Date(iso).toLocaleTimeString([], {hour:'2-digit', minute:'2-digit'}); }
                catch { return '' }
            }

            function render(messages) {
                if (!messages || !messages.length) return;

                const wasNearBottom = (feed.scrollHeight - feed.scrollTop - feed.clientHeight) <= 8;
                if (wasNearBottom) lockBottom(1800);
                const frag = document.createDocumentFragment();
                const newNodes = [];
                const mediaToLoad = [];
                for (const m of messages) {
                    const wrap = document.createElement('div');
                    wrap.className = 'msg new';

                    const meta = document.createElement('div');
                    meta.className = 'meta';
                    const handle = document.createElement('span');
                    handle.className = 'handle';
                    handle.textContent = escapeText(m.handle || 'Anon');
                    const ts = document.createElement('span');
                    ts.textContent = ' · ' + escapeText(isoToLocal(m.ts));
                    meta.appendChild(handle); meta.appendChild(ts);

                    const txt = String(m.content || '');
                    // Build embeds first so we know whether to hide the raw link(s)
                    const embeds = buildEmbedsFromText(txt);
                    const cleanedTxt = embeds.length ? stripEmbedsFromText(txt) : txt;
                    const content = document.createElement('div');
                    content.className = 'content';
                    if (cleanedTxt.trim().length > 0) {
                        content.textContent = escapeText(cleanedTxt);
                    }

                    wrap.appendChild(meta);
                    if (cleanedTxt.trim().length > 0) wrap.appendChild(content);
                    // Embeds (Tenor / direct gif/mp4)
                    for (const e of embeds) {
                        // track media load events for scroll adjustments
                        const media = e.querySelector('img.embed-media, video.embed-media');
                        if (media) mediaToLoad.push(media);
                        wrap.appendChild(e);
                    }
                    frag.appendChild(wrap);
                    newNodes.push(wrap);
                }
                feed.appendChild(frag);

                // Trigger transitions/animations on next frame
                requestAnimationFrame(() => {
                    for (const n of newNodes) {
                        n.classList.add('show');
                        // remove the 'new' class after the animation ends to avoid re-triggers
                        n.addEventListener('animationend', () => n.classList.remove('new'), { once: true });
                    }
                    // slight delay to ensure layout settled
                    setTimeout(() => {
                        const force = wasNearBottom || shouldForceBottom();
                        if (force) scrollToBottom(true, SCROLL_MS); else scrollToBottom(false);
                    }, 40);
                    // extra passes to catch late layout (fonts/embeds)
                    setTimeout(() => { if (wasNearBottom || shouldForceBottom()) scrollToBottom(false); }, 160);
                    setTimeout(() => { if (wasNearBottom || shouldForceBottom()) scrollToBottom(false); }, 420);
                    // ensure we scroll again when media finishes loading, preventing half-cut last message
                    for (const media of mediaToLoad) {
                        const handler = () => { if (wasNearBottom || shouldForceBottom()) { scrollToBottom(false); } };
                        if (media.tagName === 'IMG') {
                            if (!media.complete) media.addEventListener('load', handler, { once: true });
                        } else if (media.tagName === 'VIDEO') {
                            media.addEventListener('loadedmetadata', handler, { once: true });
                            media.addEventListener('loadeddata', handler, { once: true });
                        }
                    }
                    if (hadTenor) {
                        ensureTenorScript();
                        try {
                            if (window.Tenor && window.Tenor.Embed) {
                                window.Tenor.Embed.render();
                                // Tenor injects asynchronously; scroll after short delays
                                setTimeout(() => { if (wasNearBottom || shouldForceBottom()) { scrollToBottom(false); } }, 200);
                                setTimeout(() => { if (wasNearBottom || shouldForceBottom()) { scrollToBottom(false); } }, 600);
                            }
                        } catch {}
                    }
                });

                // Trim DOM to MAX_DOM (remove oldest from top)
                while (feed.children.length > MAX_DOM) {
                    feed.removeChild(feed.firstChild);
                }
                // Trim further to minimum needed to fill viewport + small buffer for lightweight mode
                try {
                    const children = Array.from(feed.children);
                    let h = 0, keep = 0;
                    for (let i = children.length - 1; i >= 0; i--) {
                        const el = children[i];
                        h += el.getBoundingClientRect().height;
                        keep++;
                        if (h >= feed.clientHeight * 1.2) break; // keep just over a screenful
                    }
                    const target = Math.max(keep + 3, 8); // tiny buffer, minimum 8
                    while (feed.children.length > target) feed.removeChild(feed.firstChild);
                } catch {}
            }

            function easeInOutCubic(t){ return t < 0.5 ? 4*t*t*t : 1 - Math.pow(-2*t+2,3)/2; }
            function animateScrollTo(targetTop, duration){
                const startTop = feed.scrollTop;
                const delta = targetTop - startTop;
                if (Math.abs(delta) < 1 || duration <= 0){ feed.scrollTop = targetTop; return; }
                const start = performance.now();
                function step(now){
                    const t = Math.min(1, (now - start) / duration);
                    feed.scrollTop = startTop + delta * easeInOutCubic(t);
                    if (t < 1) requestAnimationFrame(step);
                }
                requestAnimationFrame(step);
            }
            function scrollToBottom(smooth = true, duration = SCROLL_MS) {
                const target = feed.scrollHeight;
                if (smooth) animateScrollTo(target, duration); else feed.scrollTop = target;
            }

            async function tick() {
                if (!visible()) { setStatus('Paused (hidden)'); schedule(); return; }
                try {
                    // 1) Peek for last_id (cheap; served from cache on server)
                    const peekRes = await fetch(`${API_BASE}/api/messages/peek`, { cache: 'no-store' });
                    if (!peekRes.ok) throw new Error('PEEK ' + peekRes.status);
                    const peek = await peekRes.json();
                    const serverLast = Number(peek.last_id || 0);

                    if (serverLast > lastId) {
                        // 2) Only then fetch the new messages
                        const url = `${API_BASE}/api/messages?since_id=${lastId}&limit=${PAGE_LIMIT}`;
                        const res = await fetch(url, { cache: 'no-store' });
                        if (!res.ok) throw new Error('HTTP ' + res.status);
                        const data = await res.json();
                        const items = Array.isArray(data.messages) ? data.messages : [];
                        if (items.length) {
                            render(items);
                            lastId = Number(data.last_id || items[items.length-1]?.id || lastId);
                            setStatus(`Updated · ${new Date().toLocaleTimeString()}`);
                        } else {
                            lastId = Number(data.last_id ?? lastId);
                            setStatus('No new messages');
                        }
                    } else {
                        setStatus('No new messages');
                    }
                    backoff = POLL_MS; // reset on success
                } catch (err) {
                    log('poll error:', err);
                    setStatus('Error — backing off');
                    backoff = Math.min(Math.max(backoff * 1.6, POLL_MS), 10000);
                } finally {
                    schedule();
                }
            }

            function schedule() {
                clearTimeout(timer); timer = setTimeout(tick, backoff);
            }

            // Re-scroll when container size changes (e.g., window resize or fonts)
            try {
                const ro = new ResizeObserver(() => scrollToBottom(false));
                ro.observe(document.getElementById('feed'));
            } catch {}

            // Keep bottom locked on async DOM changes (e.g., Tenor injects content)
            try {
                const near = () => (feed.scrollHeight - feed.scrollTop - feed.clientHeight) <= 8;
                const mo = new MutationObserver(() => { if (near()) scrollToBottom(false); });
                mo.observe(feed, { childList: true, subtree: true });
            } catch {}

            document.addEventListener('visibilitychange', () => {
                if (visible()) { setStatus('Resumed'); backoff = POLL_MS; 
                    // force bottom for a short window after tab becomes visible
                    forceBottomUntil = Date.now() + 1500;
                    feed.classList.add('no-smooth');
                    scrollToBottom(false);
                    setTimeout(() => feed.classList.remove('no-smooth'), 120);
                    tick(); }
            });

            window.addEventListener('keydown', (e) => {
                // Debug toggle
                if (e.key === 'd' || e.key === 'D') { debug = !debug; setStatus(debug ? 'Debug ON' : 'Debug OFF'); return; }
                // +/- to change message size
                if (e.key === '+' || e.key === '=') {
                    const v = Math.min(1.5, parseFloat(msgScale.value || '1') + 0.05).toFixed(2);
                    msgScale.value = v; applyMsgScale(v); saveSetting('msgScale', v); setTimeout(() => scrollToBottom(false), 60); return;
                }
                if (e.key === '-' || e.key === '_') {
                    const v = Math.max(0.7, parseFloat(msgScale.value || '1') - 0.05).toFixed(2);
                    msgScale.value = v; applyMsgScale(v); saveSetting('msgScale', v); setTimeout(() => scrollToBottom(false), 60); return;
                }
                // [ / ] to cycle position
                if (e.key === '[' || e.key === '{') {
                    const order = ['left','center','right'];
                    const cur = positionSelect.value; const idx = Math.max(0, order.indexOf(cur) - 1);
                    const nxt = order[idx]; positionSelect.value = nxt; applyPosition(nxt); saveSetting('position', nxt); return;
                }
                if (e.key === ']' || e.key === '}') {
                    const order = ['left','center','right'];
                    const cur = positionSelect.value; const idx = Math.min(order.length-1, order.indexOf(cur) + 1);
                    const nxt = order[idx]; positionSelect.value = nxt; applyPosition(nxt); saveSetting('position', nxt); return;
                }
                // T to toggle theme
                if (e.key === 't' || e.key === 'T') {
                    const nxt = themeSelect.value === 'dark' ? 'light' : 'dark';
                    themeSelect.value = nxt; applyTheme(nxt); saveSetting('theme', nxt); return;
                }
            });

            // Kick-off: prime lastId with a first page so we don't flood the screen initially
            (async function init() {
                try {
                    let loadedCount = 0;
                    // Prime lastId via peek; then fetch a first page if any
                    const pr = await fetch(`${API_BASE}/api/messages/peek`, { cache: 'no-store' });
                    let serverLast = 0;
                    if (pr.ok) {
                        const pk = await pr.json();
                        serverLast = Number(pk.last_id || 0);
                    }
                    if (serverLast > 0) {
                        const url = `${API_BASE}/api/messages?since_id=${Math.max(0, serverLast - PAGE_LIMIT)}&limit=${PAGE_LIMIT}`;
                        const res = await fetch(url, { cache: 'no-store' });
                        if (res.ok) {
                            const data = await res.json();
                            const items = Array.isArray(data.messages) ? data.messages : [];
                            render(items);
                            lastId = Number(data.last_id || serverLast);
                            loadedCount = items.length;
                        } else {
                            lastId = serverLast;
                        }
                    } else {
                        lastId = 0;
                    }
                    setStatus(`Ready · ${loadedCount} loaded`);
                    // Jump to bottom and keep bottom locked briefly to catch late layout changes
                    forceBottomUntil = Date.now() + 1800;
                    feed.classList.add('no-smooth');
                    scrollToBottom(false);
                    setTimeout(() => feed.classList.remove('no-smooth'), 120);
                } catch {
                    setStatus('Init error');
                } finally {
                    schedule();
                }
            })();

            // Settings state
            const settingsBtn = document.getElementById('settingsBtn');
            const settingsMenu = document.getElementById('settingsMenu');
            const msgScale = document.getElementById('msgScale');
            const msgScaleVal = document.getElementById('msgScaleVal');
            const themeSelect = document.getElementById('themeSelect');
            const pollInterval = document.getElementById('pollInterval');
            const pollIntervalVal = document.getElementById('pollIntervalVal');
            const positionSelect = document.getElementById('positionSelect');

            // Persisted settings
            function saveSetting(key, val) {
                try { localStorage.setItem('wallpaper.'+key, val); } catch {}
            }
            function loadSetting(key, fallback) {
                try { return localStorage.getItem('wallpaper.'+key) ?? fallback; } catch { return fallback; }
            }

            // Message scale
            function applyMsgScale(val) {
                document.documentElement.style.setProperty('--msg-scale', val);
                msgScaleVal.textContent = (+val).toFixed(2) + 'x';
            }
            msgScale.addEventListener('input', e => {
                applyMsgScale(e.target.value);
                saveSetting('msgScale', e.target.value);
            });

            // Theme
            function applyTheme(val) {
                document.documentElement.dataset.theme = val;
                // Regenerate gradient after variable overrides are applied
                document.documentElement.style.setProperty('--gradient', `radial-gradient(120% 120% at 100% 0%, var(--bg2), var(--bg1))`);
            }
            // Poll interval
            function applyPollInterval(ms) {
                const n = Math.max(500, Math.min(10000, Number(ms)||2500));
                POLL_MS = n;
                pollIntervalVal.textContent = `${n} ms`;
                backoff = POLL_MS; // take effect next schedule
                schedule();
            }
            pollInterval.addEventListener('input', e => {
                applyPollInterval(e.target.value);
                saveSetting('interval', String(POLL_MS));
            });

            // Position
            function applyPosition(pos) {
                let container = 'center';
                let items = 'center';
                if (pos === 'left') { container = 'flex-start'; items = 'flex-start'; }
                else if (pos === 'right') { container = 'flex-end'; items = 'flex-end'; }
                document.documentElement.style.setProperty('--h-align', container);
                document.documentElement.style.setProperty('--msg-align', items);
            }
            positionSelect.addEventListener('change', e => {
                applyPosition(e.target.value);
                saveSetting('position', e.target.value);
            });
            themeSelect.addEventListener('change', e => {
                applyTheme(e.target.value);
                saveSetting('theme', e.target.value);
            });

            // Open/close menu
            function toggleMenu(force) {
                const open = force !== undefined ? force : !settingsMenu.classList.contains('open');
                settingsMenu.classList.toggle('open', open);
                if (open) settingsMenu.focus();
            }
            settingsBtn.addEventListener('click', e => {
                e.stopPropagation();
                toggleMenu();
            });
            document.addEventListener('click', e => {
                if (!settingsMenu.contains(e.target) && e.target !== settingsBtn) toggleMenu(false);
            });
            settingsMenu.addEventListener('keydown', e => {
                if (e.key === 'Escape') toggleMenu(false);
            });

            // Load settings on startup
            (function initSettings() {
                const scale = loadSetting('msgScale', '0.9');
                msgScale.value = scale;
                applyMsgScale(scale);
                const theme = loadSetting('theme', 'dark');
                themeSelect.value = theme;
                applyTheme(theme);
                const interval = loadSetting('interval', String(POLL_MS));
                pollInterval.value = interval; applyPollInterval(interval);
                const pos = loadSetting('position', 'center');
                positionSelect.value = pos; applyPosition(pos);
            })();
        })();
    </script>
    <style>
        /* Lightweight carousel/toggle styles for wallpaper-safe controls */
        .setting-inline { display: flex; align-items: center; gap: .5rem; }
        .carousel-ctrl { display:inline-flex; align-items:center; gap:.5rem; background: var(--card-bg, rgba(255,255,255,.08)); border: 1px solid rgba(255,255,255,.12); border-radius: 999px; padding: .25rem .5rem; }
        .carousel-ctrl button { appearance: none; border: 0; background: transparent; color: inherit; font: inherit; padding: .25rem .5rem; cursor: pointer; opacity:.9; }
        .carousel-ctrl button:active { transform: translateY(1px); }
        .carousel-ctrl .val { min-width: 4.5rem; text-align: center; font-weight: 600; letter-spacing: .02em; }
        .switch { position: relative; display: inline-block; width: 44px; height: 24px; }
        .switch input { opacity: 0; width: 0; height: 0; }
        .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background: #8884; transition: .2s; border-radius: 999px; }
        .slider:before { position: absolute; content: ""; height: 18px; width: 18px; left: 3px; bottom: 3px; background: white; border-radius: 50%; transition: .2s; }
        .switch input:checked + .slider { background: #4ade80aa; }
        .switch input:checked + .slider:before { transform: translateX(20px); }
    </style>
    <script>
        // Replace dropdown selects with wallpaper-friendly controls (carousel/toggle)
        (function replaceDropdowns(){
            function tryFindAlignmentSelect(){
                const selects = Array.from(document.querySelectorAll('select'));
                return selects.find(s => {
                    const vals = Array.from(s.options).map(o => (o.value||'').toLowerCase());
                    return vals.includes('left') && vals.includes('center') && vals.includes('right');
                });
            }
            function tryFindThemeSelect(){
                const selects = Array.from(document.querySelectorAll('select'));
                return selects.find(s => {
                    const vals = Array.from(s.options).map(o => (o.value||'').toLowerCase());
                    return vals.includes('dark') && vals.includes('light');
                });
            }
            function dispatchChange(el){ try { el.dispatchEvent(new Event('change', { bubbles:true })); } catch {}
            }

            // Alignment carousel
            const posSelect = window.positionSelect || tryFindAlignmentSelect();
            if (posSelect && !posSelect.dataset.replaced) {
                const order = ['left','center','right'];
                const wrap = document.createElement('div');
                wrap.className = 'setting-inline';
                const ctrl = document.createElement('div');
                ctrl.className = 'carousel-ctrl';
                const prev = document.createElement('button'); prev.type='button'; prev.setAttribute('aria-label','Prev'); prev.textContent = '‹';
                const next = document.createElement('button'); next.type='button'; next.setAttribute('aria-label','Next'); next.textContent = '›';
                const val = document.createElement('span'); val.className = 'val';
                ctrl.append(prev, val, next);
                wrap.append(ctrl);
                posSelect.style.display = 'none';
                posSelect.after(wrap);

                function apply(v){
                    const value = (v||'').toLowerCase();
                    const idx = Math.max(0, order.indexOf(value));
                    posSelect.value = order[idx];
                    val.textContent = order[idx][0].toUpperCase() + order[idx].slice(1);
                    if (typeof window.applyPosition === 'function') window.applyPosition(order[idx]); else dispatchChange(posSelect);
                    if (typeof window.saveSetting === 'function') window.saveSetting('position', order[idx]);
                }
                prev.addEventListener('click', () => { const i = order.indexOf(posSelect.value); apply(order[(i+order.length-1)%order.length]); });
                next.addEventListener('click', () => { const i = order.indexOf(posSelect.value); apply(order[(i+1)%order.length]); });
                apply(posSelect.value || 'center');
                posSelect.dataset.replaced = '1';
            }

            // Theme toggle (Light/Dark)
            const themeSelect = window.themeSelect || tryFindThemeSelect();
            if (themeSelect && !themeSelect.dataset.replaced) {
                const wrap = document.createElement('div'); wrap.className = 'setting-inline';
                const label = document.createElement('span'); label.textContent = 'Theme';
                const toggleWrap = document.createElement('label'); toggleWrap.className = 'switch';
                const input = document.createElement('input'); input.type = 'checkbox';
                const slider = document.createElement('span'); slider.className = 'slider';
                toggleWrap.append(input, slider);
                const text = document.createElement('span'); text.style.minWidth='3.5rem'; text.style.textAlign='center'; text.style.fontWeight='600';
                wrap.append(label, toggleWrap, text);
                themeSelect.style.display = 'none'; themeSelect.after(wrap);

                function applyThemeUI(val){
                    const v = (val||'').toLowerCase();
                    themeSelect.value = v;
                    input.checked = (v === 'dark');
                    text.textContent = v === 'dark' ? 'Dark' : 'Light';
                    if (typeof window.applyTheme === 'function') window.applyTheme(v); else dispatchChange(themeSelect);
                    if (typeof window.saveSetting === 'function') window.saveSetting('theme', v);
                }
                input.addEventListener('change', () => applyThemeUI(input.checked ? 'dark' : 'light'));
                applyThemeUI(themeSelect.value || 'dark');
                themeSelect.dataset.replaced = '1';
            }
        })();
    </script>
    </body>
    </html>
